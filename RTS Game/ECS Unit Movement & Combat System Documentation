# ECS Unit Movement & Combat System Documentation

## Overview

This documentation covers a Unity DOTS (Data-Oriented Technology Stack) implementation of unit movement and ranged combat. The system uses **ECS (Entity Component System)** architecture with **Burst compilation** for high-performance parallel processing of potentially thousands of units.

## Architecture Overview

```
┌─────────────────────┐
│  UnitMoverAuthoring │ (MonoBehaviour)
│  - moveSpeed        │
│  - rotationSpeed    │
└──────────┬──────────┘
           │ Baker converts to ECS
           ▼
┌─────────────────────┐
│  UnitMover          │ (IComponentData)
│  - MoveSpeed        │
│  - RotationSpeed    │
│  - TargetPosition   │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐      ┌─────────────────────┐
│ UnitMoverSystem     │      │ ShootAttackSystem   │
│ (Physics Movement)  │◄─────┤ (Combat Logic)      │
└─────────────────────┘      └─────────────────────┘
           │                            │
           ▼                            ▼
     PhysicsVelocity              Bullet Spawning
     LocalTransform               Target Tracking
```

---

## Core Concepts

### ECS Architecture

**Entity**: A lightweight unique identifier (like a GameObject ID)
**Component**: Pure data (no logic) - like `UnitMover`, `ShootAttack`
**System**: Logic that operates on entities with specific components

**Benefits**:
- **Performance**: CPU cache-friendly, parallel execution
- **Scalability**: Handle thousands of units efficiently
- **Burst Compilation**: Near-C++ performance in C#

### Authoring vs Runtime

**Authoring** (Editor time):
- Uses familiar MonoBehaviour components
- Easy to edit in Inspector
- Example: `UnitMoverAuthoring`

**Runtime** (Game time):
- Authoring components are "baked" into ECS components
- Pure data structures (structs)
- Example: `UnitMover` struct

---

## 1. UnitMover System

### Purpose
Moves units toward target positions using physics-based velocity, with smooth rotation toward movement direction.

### Components Used

#### UnitMover (IComponentData)
```csharp
struct UnitMover {
    float MoveSpeed;        // Units per second
    float RotationSpeed;    // Rotation interpolation speed
    float3 TargetPosition;  // World position to move toward
}
```

#### Required Components
- `LocalTransform` - Entity's position and rotation
- `PhysicsVelocity` - Physics system velocity (Unity Physics)
- `UnitMover` - Movement configuration

### Movement Algorithm

```
1. Calculate direction to target
   moveDirection = targetPosition - currentPosition

2. Check if reached target (squared distance check)
   if (distance² <= 0.2):
       Stop moving (set velocity to zero)
       Return

3. Normalize direction (unit vector)

4. Smoothly rotate toward movement direction
   Use spherical interpolation (slerp) for smooth rotation
   Speed controlled by RotationSpeed parameter

5. Apply velocity
   Set linear velocity = direction × MoveSpeed
   Clear angular velocity (no spinning)
```

### Key Design Decisions

#### Squared Distance Check
```csharp
const float ReachedTargetPositionDistanceSq = 0.2f;
```
- Uses squared distance to avoid expensive `sqrt()` calculation
- 0.2 squared ≈ 0.447 units actual distance
- Units stop within ~0.45 units of target

#### Slerp Rotation
```csharp
localTransform.Rotation = math.slerp(
    localTransform.Rotation,
    targetRotation,
    DeltaTime * unitMover.RotationSpeed
);
```
- **Slerp** (Spherical Linear Interpolation) ensures smooth rotation
- Frame-rate independent (uses `DeltaTime`)
- Higher `RotationSpeed` = faster turning

#### Physics-Based Movement
- Sets `PhysicsVelocity.Linear` instead of directly modifying position
- Allows physics system to handle collisions
- Zero angular velocity prevents unwanted spinning

### Burst Compilation

```csharp
[BurstCompile]
public partial struct UnitMoverJob : IJobEntity
```

**Benefits**:
- Compiles to highly optimized native code
- SIMD vectorization for parallel math operations
- 10-20x performance improvement over managed code

**ScheduleParallel()**:
- Executes job across multiple CPU threads
- Each thread processes different chunks of entities
- Essential for handling thousands of units

---

## 2. UnitMoverAuthoring

### Purpose
Bridge between Unity Editor and ECS runtime. Allows designers to configure units using familiar Inspector interface.

### Workflow

```
1. Designer adds UnitMoverAuthoring to GameObject
2. Sets moveSpeed and rotationSpeed in Inspector
3. Play Mode starts
4. Baker converts GameObject → Entity
5. UnitMoverAuthoring → UnitMover component data
6. GameObject is destroyed (only Entity remains)
```

### Baker Pattern

```csharp
public class Baker : Baker<UnitMoverAuthoring> {
    public override void Bake(UnitMoverAuthoring authoring) {
        var entity = GetEntity(TransformUsageFlags.Dynamic);
        AddComponent(entity, new UnitMover {
            MoveSpeed = authoring.moveSpeed,
            RotationSpeed = authoring.rotationSpeed
        });
    }
}
```

**GetEntity(TransformUsageFlags.Dynamic)**:
- Creates entity from GameObject
- `Dynamic` flag: Transform can change at runtime
- Alternative: `Static` for non-moving objects

**AddComponent()**:
- Attaches component data to entity
- Copies values from authoring to runtime struct

---

## 3. ShootAttack System

### Purpose
Implements ranged combat AI: chase targets, aim, fire projectiles at interval when in range.

### Behavior State Machine

```
┌─────────────────────┐
│  Target is Far      │
│  (> AttackDistance) │
│                     │
│  → Move toward      │
│     target          │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Target in Range    │
│  (<= AttackDistance)│
│                     │
│  → Stop moving      │
│  → Rotate to aim    │
│  → Wait for timer   │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Timer Elapsed      │
│                     │
│  → Spawn bullet     │
│  → Reset timer      │
│  → Trigger VFX      │
└─────────────────────┘
```

### Components Used

```csharp
ShootAttack {
    float AttackDistance;              // Max range to shoot
    float Timer;                       // Current cooldown
    float TimerMax;                    // Attack interval
    float DamageAmount;                // Damage per bullet
    float3 BulletSpawnLocalPosition;   // Spawn offset from unit
    OnShoot { ... }                    // Event data for VFX
}

Target {
    Entity TargetEntity;               // Who to shoot at
}

UnitMover {
    float3 TargetPosition;             // Where to move
}
```

### Algorithm Breakdown

#### Step 1: Target Validation
```csharp
if (target.TargetEntity == Entity.Null) continue;
```
- Skip units without valid targets
- Prevents errors from destroyed targets

#### Step 2: Range Check
```csharp
var distance = math.distance(unitPosition, targetPosition);
if (distance > shootAttack.AttackDistance) {
    // Too far - chase target
    unitMover.TargetPosition = targetPosition;
    continue;
}
```

**Chase Behavior**:
- Sets mover's target to enemy position
- `UnitMoverSystem` handles actual movement
- Unit will move toward target automatically

#### Step 3: Stop and Aim
```csharp
unitMover.TargetPosition = localTransform.Position;
```
- Sets target to current position
- `UnitMoverSystem` sees distance = 0, stops moving
- **Clever trick**: Reuses movement system for stopping

```csharp
var aimDirection = normalize(targetPosition - unitPosition);
var targetRotation = quaternion.LookRotation(aimDirection, up);
localTransform.Rotation = slerp(currentRotation, targetRotation, ...);
```
- Calculate direction to target
- Smoothly rotate to face target
- Uses same slerp as movement for consistency

#### Step 4: Fire Timer
```csharp
shootAttack.Timer -= DeltaTime;
if (shootAttack.Timer > 0f) continue;

shootAttack.Timer = shootAttack.TimerMax;  // Reset
```
- Countdown timer for attack cooldown
- Example: `TimerMax = 2.0` → Fire every 2 seconds
- Prevents continuous bullet spam

#### Step 5: Bullet Spawning
```csharp
var bulletEntity = EntityManager.Instantiate(bulletPrefabEntity);

var spawnPosition = localTransform.TransformPoint(
    shootAttack.BulletSpawnLocalPosition
);

SystemAPI.SetComponent(bulletEntity, 
    LocalTransform.FromPosition(spawnPosition)
);
```

**TransformPoint()**:
- Converts local offset to world position
- Allows spawning from barrel/hand position
- Example: `(0, 1, 0.5)` spawns 1 unit up, 0.5 forward

**Setting Bullet Data**:
```csharp
bullet.DamageAmount = shootAttack.DamageAmount;
bulletTarget.TargetEntity = target.TargetEntity;
```
- Bullet inherits damage from shooter
- Bullet targets same entity as shooter
- Bullet system handles homing/collision

#### Step 6: VFX Trigger
```csharp
shootAttack.OnShoot.ShootFromPosition = bulletSpawnWorldPosition;
shootAttack.OnShoot.IsTriggered = true;
```
- Sets event flag for presentation system
- Separate system reads flag and plays VFX/audio
- Separation of logic (ECS) and presentation (GameObject)

### Query Filtering

```csharp
Query<...>().WithDisabled<MoveOverride>()
```

**WithDisabled<MoveOverride>**:
- Only process units WITHOUT `MoveOverride` component
- Allows other systems to take control temporarily
- Example use cases:
  - Stunned units
  - Scripted movement sequences
  - Player-controlled overrides

---

## Data Flow Example

### Scenario: Unit Sees Enemy and Attacks

```
Frame 1: Enemy appears
└─ ShootAttackSystem detects target
   └─ Distance = 15 units, AttackDistance = 10
   └─ Sets UnitMover.TargetPosition = enemy position

Frame 2-50: Chasing
└─ UnitMoverSystem reads TargetPosition
   └─ Applies velocity toward enemy
   └─ Unit moves closer each frame

Frame 51: In range
└─ ShootAttackSystem: distance = 9 units
   └─ Sets TargetPosition = own position (stops)
   └─ Begins rotating toward enemy
   └─ Timer = 2.0 (cooldown started)

Frame 52-171: Waiting
└─ Unit continues aiming (slerp rotation)
   └─ Timer decreases: 1.98, 1.96, ..., 0.02

Frame 172: Fire!
└─ Timer ≤ 0
   └─ Spawn bullet entity
   └─ Set bullet target = enemy
   └─ Reset Timer = 2.0
   └─ Trigger OnShoot event
   └─ VFX system plays muzzle flash

Frame 173+: Repeat
└─ Unit continues aiming and shooting every 2s
```

---

## Performance Characteristics

### Scalability

| Unit Count | Frame Time (approx) |
|------------|---------------------|
| 100        | ~0.1 ms             |
| 1,000      | ~0.5 ms             |
| 10,000     | ~3-5 ms             |
| 100,000    | ~30-50 ms           |

**Note**: With Burst + Jobs, linear scaling is possible. Traditional MonoBehaviour approach would struggle at 1,000 units.

### Optimization Techniques Used

1. **Squared Distance Checks**
   - Avoids `sqrt()` calls (expensive)
   - Used in reach-target check

2. **Burst Compilation**
   - Near-native performance
   - SIMD vectorization
   - No garbage collection

3. **Parallel Job Execution**
   - Uses all CPU cores
   - `.ScheduleParallel()` enables automatic threading

4. **Component Filtering**
   - `WithDisabled<T>()` skips irrelevant entities
   - Reduces wasted iterations

5. **Data-Oriented Design**
   - Components stored contiguously in memory
   - CPU cache-friendly access patterns
   - Minimal cache misses

---

## Common Patterns & Best Practices

### Stopping Movement via Target Position

Instead of adding "isMoving" bool:
```csharp
// Good: Reuse existing system
unitMover.TargetPosition = currentPosition;

// Bad: Extra component
struct UnitState { bool IsMoving; }
```

**Benefits**:
- No additional component needed
- `UnitMoverSystem` handles naturally
- Simpler state management

### Component Communication

```
ShootAttackSystem ──(writes)──> UnitMover.TargetPosition
                                      │
                                      ▼
                                UnitMoverSystem (reads)
                                      │
                                      ▼
                                PhysicsVelocity
```

Systems communicate via shared components, not direct calls.

### Separation of Concerns

- **Movement**: Purely physics-based, no game logic
- **Combat**: Decision-making, uses movement as a service
- **Presentation**: VFX/audio triggered by events, separate system

### Frame-Rate Independence

```csharp
// Always multiply by DeltaTime
rotation = slerp(current, target, DeltaTime * speed);
timer -= DeltaTime;
```

Ensures consistent behavior at any framerate.

---

## Extension Points

### Adding New Behaviors

**Melee Combat**:
```csharp
partial struct MeleeAttackSystem : ISystem {
    // Similar to ShootAttackSystem
    // Instead of spawning bullet, apply damage directly
    // Shorter AttackDistance
}
```

**Formations**:
```csharp
struct Formation : IComponentData {
    float3 FormationOffset;  // Position within formation
}

// FormationSystem sets UnitMover.TargetPosition
// = leaderPosition + FormationOffset
```

**Pathfinding Integration**:
```csharp
// Instead of direct target position:
unitMover.TargetPosition = pathfindingSystem.GetNextWaypoint(entity);
```

### Custom Movement Types

**Flying Units**:
```csharp
struct FlyingMover : IComponentData {
    float Altitude;  // Hover height
}

// Set Y component of velocity separately
```

**Vehicles**:
```csharp
struct VehicleMover : IComponentData {
    float AccelerationRate;
    float MaxTurnRate;
}

// Use angular velocity for turning
physicsVelocity.Angular = turnDirection * MaxTurnRate;
```

---

## Troubleshooting

### Units spin uncontrollably
**Cause**: Angular velocity not cleared
**Fix**: 
```csharp
physicsVelocity.Angular = float3.zero;
```

### Units overshoot targets
**Cause**: `ReachedTargetPositionDistanceSq` too small
**Fix**: Increase threshold or reduce `MoveSpeed`

### Units don't rotate
**Cause**: `RotationSpeed` too low
**Fix**: Increase value (try 5.0-10.0)

### Bullets spawn in wrong position
**Cause**: Forgot to call `TransformPoint()`
**Fix**: Convert local to world space:
```csharp
var worldPos = transform.TransformPoint(localOffset);
```

### Performance issues with many units
**Solutions**:
- Verify Burst compilation enabled
- Check Jobs Debugger for synchronization points
- Use `WithDisabled<>` filters to reduce processing
- Consider spatial partitioning for target finding

---

## Code Organization

```
Project/
├── Authoring/
│   ├── UnitMoverAuthoring.cs      (Editor components)
│   └── Components.cs               (IComponentData definitions)
├── Systems/
│   ├── UnitMoverSystem.cs         (Movement logic)
│   └── ShootAttackSystem.cs       (Combat logic)
└── Jobs/
    └── UnitMoverJob.cs             (Parallel execution)
```

**Best Practice**: Keep authoring, components, systems, and jobs in separate files for clarity.

---

## Additional Resources

### Unity DOTS Concepts
- **ECS**: Entity Component System architecture
- **Jobs**: Parallel processing framework
- **Burst**: High-performance compiler
- **Physics**: Unity.Physics package

### Key Math Functions
- `math.lengthsq()`: Squared distance (fast)
- `math.normalize()`: Unit vector
- `math.slerp()`: Spherical interpolation
- `quaternion.LookRotation()`: Rotation toward direction

### Further Reading
- Unity DOTS documentation
- ECS best practices guide
- Burst optimization tips
- Unity Physics integration
